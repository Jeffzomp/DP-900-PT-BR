---
ms.openlocfilehash: bd96d4c9278b37a2a3626abd3bd91dd20a15e2e1
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050416"
---
<a name="https-proxy-agent"></a>https-proxy-agent
================
### <a name="an-https-proxy-httpagent-implementation-for-https"></a>Uma implementação de proxy HTTP(s) de `http.Agent` para HTTPS
[![Status de build](https://github.com/TooTallNate/node-https-proxy-agent/workflows/Node%20CI/badge.svg)](https://github.com/TooTallNate/node-https-proxy-agent/actions?workflow=Node+CI)

Este módulo fornece uma implementação de `http.Agent` que se conecta a um servidor proxy HTTP ou HTTPS especificado e pode ser usado com o módulo `https` interno.

Especificamente, essa implementação de `Agent` se conecta a um servidor "proxy" intermediário e emite o [método HTTP CONNECT][CONNECT], que informa ao proxy que ele deve abrir uma conexão TCP direta com o servidor de destino.

Como esse agente implementa o método HTTP CONNECT, ele também funciona com outros protocolos que usam este método ao se conectar por proxies (ou seja, WebSockets).
Confira a seção "Exemplos" abaixo para obter mais detalhes.


<a name="installation"></a>Instalação
------------

Instalar com `npm`:

``` bash
$ npm install https-proxy-agent
```


<a name="examples"></a>Exemplos
--------

#### <a name="https-module-example"></a>Exemplo do módulo `https`

``` js
var url = require('url');
var https = require('https');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// HTTPS endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'https://graph.facebook.com/tootallnate';
console.log('attempting to GET %j', endpoint);
var options = url.parse(endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var agent = new HttpsProxyAgent(proxy);
options.agent = agent;

https.get(options, function (res) {
  console.log('"response" event!', res.headers);
  res.pipe(process.stdout);
});
```

#### <a name="ws-websocket-connection-example"></a>Exemplo de conexão do WebSocket `ws`

``` js
var url = require('url');
var WebSocket = require('ws');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// WebSocket endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'ws://echo.websocket.org';
var parsed = url.parse(endpoint);
console.log('attempting to connect to WebSocket %j', endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var options = url.parse(proxy);

var agent = new HttpsProxyAgent(options);

// finally, initiate the WebSocket connection
var socket = new WebSocket(endpoint, { agent: agent });

socket.on('open', function () {
  console.log('"open" event!');
  socket.send('hello world');
});

socket.on('message', function (data, flags) {
  console.log('"message" event! %j %j', data, flags);
  socket.close();
});
```

<a name="api"></a>API
---

### <a name="new-httpsproxyagentobject-options"></a>new HttpsProxyAgent(Object options)

A classe `HttpsProxyAgent` implementa uma subclasse `http.Agent` que se conecta ao servidor proxy "HTTP(s) especificado" para fazer proxy de solicitações HTTPS e/ou do WebSocket. Isso é obtido usando o [método HTTP `CONNECT`][CONNECT].

O argumento `options` pode ser um URI de cadeia de caracteres do servidor proxy a ser usado ou um objeto "options" com propriedades mais específicas:

  * `host` – Cadeia de caracteres – Host do proxy com o qual a conexão será feita (`hostname` também pode ser usado). Obrigatórios.
  * `port` – Número – Porta do proxy com a qual a conexão será feita. Obrigatórios.
  * `protocol` – Cadeia de caracteres – Se `https:`, use TLS para se conectar ao proxy.
  * `headers` – Objeto – Cabeçalhos HTTP adicionais a serem enviados no método HTTP CONNECT.
  * Todas as outras opções fornecidas são passadas para as funções `net.connect()`/`tls.connect()`.


<a name="license"></a>Licença
-------

(A licença MIT)

Direitos autorais (c) 2013 Nathan Rajlich &lt;nathan@tootallnate.net&gt;

A permissão é concedida por meio deste instrumento, gratuitamente, a qualquer pessoa que obtenha uma cópia deste software e dos arquivos de documentação associados (o 'Software') para lidar com o Software sem restrição, incluindo, entre outros, os direitos de uso, cópia, modificação, mesclagem, publicação, distribuição, sublicenciamento e/ou venda de cópias do Software e a permissão para que as pessoas que receberem o Software façam isso, de acordo com as seguintes condições:

O aviso de direitos autorais acima e esta notificação de permissão deverão ser incluídos em todas as cópias ou partes substanciais do Software.

O SOFTWARE É FORNECIDO "NO ESTADO EM QUE SE ENCONTRA" SEM NENHUM TIPO DE GARANTIA, EXPLÍCITA OU IMPLÍCITA, INCLUINDO, MAS SEM LIMITAÇÃO, AS GARANTIAS DE COMERCIALIZAÇÃO, ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA E DE NÃO VIOLAÇÃO.
EM NENHUMA CIRCUNSTÂNCIA OS AUTORES OU OS DETENTORES DE DIREITOS AUTORAIS SERÃO RESPONSABILIZADOS POR QUALQUER REIVINDICAÇÃO, DANOS OU OUTRA OBRIGAÇÃO, SEJA EM UMA AÇÃO DE CONTRATO, ATO ILÍCITO EXTRACONTRATUAL OU DECORRENTES DO, EM VIRTUDE DO OU EM CONEXÃO COM O SOFTWARE, USO OU OUTRAS NEGOCIAÇÕES NO SOFTWARE.

[CONNECT]: http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_Tunneling
