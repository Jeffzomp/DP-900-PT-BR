---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050255"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![Status de build](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![jsbi no npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

O JSBI é uma implementação pure-JavaScript da [proposta BigInt do ECMAScript](https://tc39.es/proposal-bigint/), que se tornou parte oficial da linguagem JavaScript no ES2020.

## <a name="installation"></a>Instalação

```sh
npm install jsbi --save
```

## <a name="usage"></a>Uso

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Observação: chame `toString` explicitamente em todas as instâncias de `JSBI` ao executar `console.log()` nelas para ver a representação numérica (por exemplo, `String(max)` ou `max.toString()`). Sem ele (por exemplo `console.log(max)`), você verá o objeto que representa o valor.

Use [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) para transpilar o código JSBI no código BigInt nativo.

Confira as instruções detalhadas abaixo para obter mais informações.

## <a name="why"></a>Por quê?

[Os BigInts nativos já estão sendo enviados](https://v8.dev/features/bigint) em navegadores modernos (durante a escrita deste artigo, o Google Chrome 67 ou superior, o Opera 54 e o Firefox 68 ou as respectivas versões superiores) e no Node.js (v10.4 ou superior), e espera-se que eles cheguem a outros navegadores no futuro , o que significa que você ainda não pode usá-los se quiser que o código seja executado em qualquer lugar.

Para usar o BigInts no código hoje, você precisa de uma biblioteca. Mas há uma dificuldade: a proposta BigInt muda o comportamento dos operadores (como `+`, `>=` etc.) para trabalhar com BigInts. Nessas alterações é impossível aplicar o polyfill diretamente e elas também estão tornando inviável (na maioria dos casos) transpilar o código BigInt em código de fallback usando o Babel ou ferramentas semelhantes. O motivo é que essa transpilação teria que substituir cada operador único no programa por uma chamada a alguma função que execute verificações de tipo nas entradas, o que prejudicaria o desempenho de modo inaceitável.

A solução é fazer o contrário: escrever o código usando a sintaxe de uma biblioteca e [transpilá-lo em código BigInt nativo](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) quando disponível. O JSBI foi projetado exatamente para essa finalidade: ele fornece uma implementação de “polyfill” do BigInt que se comporta exatamente como os próximos BigInts nativos, mas com uma sintaxe que você pode enviar em todos os navegadores no momento.

Suas vantagens em relação a outras bibliotecas de big-integer existentes são:

- ele se comporta exatamente como BigInts nativos quando eles ficam disponíveis, portanto, a fim de migrar para eles, você pode atualizar [mecanicamente](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) a sintaxe do código, sem precisar repensar sua lógica.
- forte enfoque no desempenho. Em média, o JSBI é competitivo em termos de desempenho com a implementação nativa que o Google Chrome está oferecendo no momento.

## <a name="how"></a>Como posso fazer isso?

Exceto pelas diferenças mecânicas na sintaxe, você usa o JSBI-BigInts [exatamente como usaria BigInts nativos](https://developers.google.com/web/updates/2018/05/bigint). Algumas coisas até parecem iguais, depois de substituir `BigInt` por `JSBI.BigInt`:

| Operação            | BigInts nativos          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Criação por meio de cadeia de caracteres | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Criação por meio de número | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Conversão em cadeia de caracteres | `a.toString(radix)`     | `a.toString(radix)`      |
| Conversão em número | `Number(a)`             | `JSBI.toNumber(a)`       |
| Truncation           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Verificação de tipo           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

A maioria dos operadores é substituída por chamadas de método:

| Operação                   | BigInts nativos | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Adição                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Subtração                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Multiplicação              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| Divisão                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Resto                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Exponenciação              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Negação                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Negação bit a bit            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Deslocamento para a esquerda               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Deslocamento para a direita              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| “and” bit a bit               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| “or” bit a bit                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| “xor” bit a bit               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Comparação com outros BigInts | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

As funções acima operam apenas em BigInts. (Elas não executam verificações de tipo na implementação atual, pois essas verificações são uma perda de tempo quando presumimos que você sabe o que está fazendo. Não tente chamá-las com outras entradas ou haverá “estranhas”!)

Algumas operações são mais interessantes quando você fornece entradas de tipos mistos, por exemplo, comparando um BigInt com um Número ou concatenando uma cadeia de caracteres com um BigInt. Elas são implementadas como funções estáticas nomeadas de acordo com os respectivos operadores nativos:

| Operação                       | BigInts nativos | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Comparação de igualdade abstrata    | `x == y`       | `JSBI.EQ(x, y)`  |
| “diferente” genérico             | `x != y`       | `JSBI.NE(x, y)`  |
| “inferior a” genérico             | `x < y`        | `JSBI.LT(x, y)`  |
| “igual ou inferior a” genérico    | `x <= y`       | `JSBI.LE(x, y)`  |
| “superior a” genérico          | `x > y`        | `JSBI.GT(x, y)`  |
| “igual ou superior a” genérico | `x >= y`       | `JSBI.GE(x, y)`  |
| Adição genérica                | `x + y`        | `JSBI.ADD(x, y)` |

Os nomes das variáveis `x` e `y` aqui indicam que as variáveis podem se referir a qualquer coisa, por exemplo: `JSBI.GT(101.5, BigInt('100'))` ou `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

Mas também há algumas coisas sem suporte:

| Operação sem suporte | BigInts nativos | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| literais              | `a = 123n;`    | N/A ☹                                |
| incremento             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| decremento             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

É impossível replicar o comportamento exato dos operadores nativos `++` e `--` com funções estáticas. Como o JSBI deve ser transpilado no fim das contas, ele não fornece uma alternativa semelhante, mas diferente. Você pode usar `JSBI.add()` e `JSBI.subtract()`, nesse caso.

## <a name="when"></a>Quando?

Agora! A biblioteca JSBI está pronta para ser usada hoje.

Quando os BigInts tiverem suporte nativo em todos os lugares, use [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) para transpilar o código JSBI em código BigInt nativo de uma vez por todas.

Veja [nosso rastreador de problemas](https://github.com/GoogleChromeLabs/jsbi/issues) para saber mais sobre os planos futuros do JSBI e participe da discussão!

Um plano futuro mais vago é usar a biblioteca JSBI (ou uma extensão para ela) como um campo de preparo de novas funcionalidades relacionadas ao BigInt. A intenção da proposta oficial é começar com o mínimo e deixar outras “funções de biblioteca” para novas propostas. Exemplos são uma função `exp`+`mod` combinada e funções de manipulação de bits.

## <a name="development"></a>Desenvolvimento

1. Clone esse repositório e execute `cd` no diretório local.

1. Use a versão de Node.js especificada em `.nvmrc`:

     ```sh
     nvm use
     ```

1. Instale as dependências de desenvolvimento:

    ```sh
    npm install
    ```

1. Execute os testes:

    ```sh
    npm test
    ```

    Confira `npm run` para ver a lista de comandos.

## <a name="for-maintainers"></a>Para mantenedores

### <a name="how-to-publish-a-new-release"></a>Como publicar uma nova versão

1. No branch `main`, aumente o número da versão em `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Em vez de `patch`, use `minor` ou `major`, [conforme o necessário](https://semver.org/).

    Observe que isso produz um commit e uma tag do Git.

1. Envie por push o commit e a tag de lançamento:

    ```sh
    git push
    ```

    Depois, a CI publica a nova versão automaticamente no npm.
