---
ms.openlocfilehash: f8a035cf72e9aaa28084cf7e8e5cd0749b5653dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050396"
---
# <a name="node-jwa-build-statushttpstravis-ciorgbrianloveswordsnode-jwa"></a>node-jwa [![Status de build](https://travis-ci.org/brianloveswords/node-jwa.svg?branch=master)](https://travis-ci.org/brianloveswords/node-jwa)

Uma implementação de [Algoritmos Web JSON](http://tools.ietf.org/id/draft-ietf-jose-json-web-algorithms-08.html) com foco (exclusivamente, neste momento) nos algoritmos necessários para [assinaturas de Web JSON](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Essa biblioteca dá suporte a todos os algoritmos de criptografia obrigatórios, recomendados e opcionais para JWS:

Valor de parâmetro do algoritmo | Algoritmo de Assinatura Digital ou MAC
----------------|----------------------------
HS256 | Algoritmo HMAC usando o hash SHA-256
HS384 | Algoritmo HMAC usando o hash SHA-384
HS512 | Algoritmo HMAC usando o hash SHA-512
RS256 | Algoritmo RSASSA usando o hash SHA-256
RS384 | Algoritmo RSASSA usando o hash SHA-384
RS512 | Algoritmo RSASSA usando o hash SHA-512
PS256 | Algoritmo RSASSA-PSS usando o hash SHA-256
PS384 | Algoritmo RSASSA-PSS usando o hash SHA-384
PS512 | Algoritmo RSASSA-PSS usando o hash SHA-512
ES256 | Algoritmo ECDSA usando a curva P-256 e o hash SHA-256
ES384 | Algoritmo ECDSA usando a curva P-384 e o hash SHA-384
ES512 | Algoritmo ECDSA usando a curva P-521 e o hash SHA-512
nenhum | Não incluído nenhum valor de assinatura digital ou de MAC

Observe que PS* só funciona no Node 6.12 e superiores (excluindo o 7.x).

# <a name="requirements"></a>Requisitos

Para executar os testes, é necessária uma versão recente do OpenSSL. **A versão que vem com o OS X (OpenSSL 0.9.8r 8 de fevereiro
2011) não é recente o suficiente**, pois não dá suporte total às chaves ECDSA. Você precisará usar uma versão inferior à 1.0.0. Eu testei com o OpenSSL 1.0.1c de 10 de maio de 2012.

# <a name="testing"></a>Teste

Para fazer os testes, execute

```bash
$ npm test
```

Isso vai gerar um monte de pares de chaves a serem usados no teste. Se você quiser gerar novos pares de chaves, execute `make clean` antes de executar `npm test` novamente.

## <a name="methodology"></a>Metodologia

Gerei `openssl dgst -sign` para testar a assinatura OpenSSL → verificar o JS e `openssl dgst -verify` para testar a assinatura JS → verificar o OpenSSL de cada um dos algoritmos RSA e ECDSA.

# <a name="usage"></a>Uso

## <a name="jwaalgorithm"></a>jwa(algorithm)

Cria um objeto `jwa` com os métodos `sign` e `verify` do algoritmo. Os valores válidos para o algoritmo podem ser encontrados na tabela acima (`'HS256'`, `'HS384'` etc.) e diferenciam maiúsculas de minúsculas. Se um valor de algoritmo inválido é passado, um `TypeError` é gerado.


## <a name="jwasigninput-secretorprivatekey"></a>jwa#sign(input, secretOrPrivateKey)

Assinar uma entrada com um segredo para algoritmos HMAC ou uma chave privada para algoritmos RSA e ECDSA.

Se a entrada ainda não for uma cadeia de caracteres ou um buffer, `JSON.stringify` será chamado para tentar convertê-la.

Para o algoritmo HMAC, `secretOrPrivateKey` deve ser uma cadeia de caracteres ou um buffer. Para ECDSA e RSA, o valor deve ser uma cadeia de caracteres que represente uma chave **privada** codificada em PEM.

Emitir a [base64url](http://en.wikipedia.org/wiki/Base64#URL_applications) formatada. Essa opção é para conveniência, pois a JWS espera a assinatura nesse formato. Se o aplicativo precisar da saída em um formato diferente, [abra um problema](https://github.com/brianloveswords/node-jwa/issues). Enquanto isso, você pode usar [brianloveswords/base64url](https://github.com/brianloveswords/base64url) para decodificar a assinatura.

Do Node.js *v0.11.8* em diante, o suporte a SPKAC foi introduzido. Se a versão do Node.js for atendida, você poderá passar um objeto `{ key: '..', passphrase: '...' }`


## <a name="jwaverifyinput-signature-secretorpublickey"></a>jwa#verify(input, signature, secretOrPublicKey)

Verificar uma assinatura. Retorna `true` ou `false`.

`signature` deve ser uma cadeia de caracteres codificada em base64url.

Para o algoritmo HMAC, `secretOrPublicKey` deve ser uma cadeia de caracteres ou um buffer. Para ECDSA e RSA, o valor deve ser uma cadeia de caracteres que represente uma chave **pública** codificada em PEM.


# <a name="example"></a>Exemplo

HMAC
```js
const jwa = require('jwa');

const hmac = jwa('HS256');
const input = 'super important stuff';
const secret = 'shhhhhh';

const signature = hmac.sign(input, secret);
hmac.verify(input, signature, secret) // === true
hmac.verify(input, signature, 'trickery!') // === false
```

Com chaves
```js
const fs = require('fs');
const jwa = require('jwa');
const privateKey = fs.readFileSync(__dirname + '/ecdsa-p521-private.pem');
const publicKey = fs.readFileSync(__dirname + '/ecdsa-p521-public.pem');

const ecdsa = jwa('ES512');
const input = 'very important stuff';

const signature = ecdsa.sign(input, privateKey);
ecdsa.verify(input, signature, publicKey) // === true
```
## <a name="license"></a>Licença

MIT

```
Copyright (c) 2013 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```
