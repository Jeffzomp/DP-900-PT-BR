---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050241"
---
# <a name="tools"></a>Ferramentas

## <a name="clang-format"></a>clang-format

As ferramentas de verificação de formato clang foram projetadas para verificar linhas de código alteradas em comparação com git-refs especificados.

## <a name="migration-script"></a>Script de migração

A ferramenta de migração foi projetada para reduzir o trabalho repetitivo no processo de migração. No entanto, o script não pretende converter tudo para você. Geralmente há algumas correções pequenas e uma reconstrução importante necessárias.

### <a name="how-to-use"></a>Como usar

Para executar o script de conversão, primeiro verifique se você tem a mais recente `node-addon-api` no diretório `node_modules`.
```
npm install node-addon-api
```

Depois, execute o script passando o diretório do projeto
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

Após a conclusão, recompile e depure o que o script deixou passar.


### <a name="quick-fixes"></a>Correções rápidas
Veja a lista de coisas que podem ser corrigidas facilmente.
  1. Altere o valor retornado dos métodos para nulo se não for retornado um valor para JavaScript.
  2. Use `.` para acessar o atributo ou para invocar a função de membro em Napi::Object em vez de `->`.
  3. `Napi::New(env, value);` para `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>Reconstruções importantes
A implementação de `Napi::ObjectWrap` é bem diferente da implementação de NAN. `Napi::ObjectWrap` usa um ponteiro para o objeto encapsulado e cria uma referência ao objeto encapsulado dentro do construtor ObjectWrap. `Napi::ObjectWrap` também associa os métodos de instância do objeto encapsulado ao módulo JavaScript e não a métodos estáticos como NAN.

Portanto, se você usar Nan::ObjectWrap no módulo, precisará executar as etapas a seguir.

  1. Converta a função [ClassName]::New em uma função de construtor que usa um `Napi::CallbackInfo`. Declare-a como
```
[ClassName](const Napi::CallbackInfo& info);
```
e defina-a como
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
Dessa forma, o construtor `Napi::ObjectWrap` será invocado depois que a instância do objeto for criada e `Napi::ObjectWrap` poderá usar o ponteiro `this` para criar uma referência ao objeto encapsulado.

  2. Mova o código do construtor original para o novo construtor. Exclua o construtor original.
  3. Na função de inicialização de classe, associe métodos nativos da maneira a seguir.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. Na função em que você precisa desencapsular o ObjectWrap no NAN como `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`, use o ponteiro `this` diretamente como o objeto desencapsulado, pois cada instância de ObjectWrap está associada a uma instância de objeto exclusiva.


Se você ainda encontrar problemas após seguir este guia, envie-nos um problema detalhado e tentaremos resolvê-lo.
