---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050048"
---
# <a name="tar-fs"></a>tar-fs

Associações de sistema de arquivos para [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![status de build](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>Uso

tar-fs permite que você empacote diretórios em tarballs e extraia tarballs em diretórios.

Essa opção não faz gunzip. Então, se você quiser extrair um `.tar.gz` com ela, use algo como [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) além dela.

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

Para ignorar vários arquivos durante o empacotamento ou a extração, adicione uma função ignore às opções. `ignore` também é um alias para `filter`. Além disso, você receberá `header` se usar ignore durante a extração.
Dessa forma, você também pode filtrar por metadados.

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

Você também pode especificar quais entradas quer empacotar usando a opção `entries`

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

Se você quiser modificar os cabeçalhos durante o empacotamento ou a extração, adicione uma função map às opções

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

Da mesma forma, você pode usar `mapStream` para modificar os fluxos de arquivo de entrada/saída

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Defina `options.fmode` e `options.dmode` para garantir que os arquivos/diretórios extraídos tenham os modos correspondentes

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

O uso de `dmode` e `fmode` poderá ser útil se você estiver empacotando/desempacotando tarballs entre *nix/windows, para garantir que todos os arquivos/diretórios desempacotados sejam legíveis.

Como alternativa, você pode definir `options.readable` e/ou `options.writable` para definir o dmode e o fmode como legível/gravável.

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Defina `options.strict` para `false` se você quiser ignorar erros devido a tipos de entrada sem suporte (como arquivos de dispositivo)

Para desreferenciar symlinks (empacotar o conteúdo do symlink em vez do próprio link), defina `options.dereference` como `true`.

## <a name="copy-a-directory"></a>Copiar um diretório

Copiar um diretório com permissões e mtime intacto é tão simples quanto

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>Interação com [`tar-stream`](https://github.com/mafintosh/tar-stream)

Use `finalize: false` e o gancho `finish` para deixar o fluxo de pacote aberto para entradas adicionais (confira [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)) e use `pack` para passar um fluxo de pacote existente.

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>Desempenho

O empacotamento e a extração de 6,1 GB com 2496 diretórios e 2398 arquivos gera os seguintes resultados no meu Macbook Air.
[Veja o parâmetro de comparação aqui](https://gist.github.com/mafintosh/8102201)

* tar-fs: 34,261 segundos
* [node-tar](https://github.com/isaacs/node-tar): 366,123 segundos (ou 10 vezes mais lento)

## <a name="license"></a>Licença

MIT
