---
ms.openlocfilehash: c6dc9b216d8255c51f2dc575a7c59dce25deff9e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050210"
---
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# <a name="uuid-cihttpsgithubcomuuidjsuuidactionsqueryworkflow3aci-browserhttpsgithubcomuuidjsuuidactionsqueryworkflow3abrowser"></a>uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Navegador](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

Para a criação de UUIDs [RFC4122](http://www.ietf.org/rfc/rfc4122.txt)

- **Completo** – Suporte para UUIDs RFC4122 versões 1, 3, 4 e 5
- **Multiplataforma** – Suporte para...
  - CommonJS, [módulos ECMAScript](#ecmascript-modules) e [builds de CDN](#cdn-builds)
  - Node 8, 10, 12 e 14
  - Navegadores Chrome, Safari, Firefox, Edge e IE 11
  - Empacotadores de módulos Webpack e rollup.js
  - [React Native/Expo](#react-native--expo)
- **Seguro** – Valores aleatórios com criptografia forte
- **Pequena** – Sem nenhuma dependência, tamanho pequeno, compatível com empacotadores que fazem "agitação de árvore" para remover o código morto
- **CLI** – Inclui o utilitário de [linha de comando `uuid`](#command-line)

**Atualização de `uuid@3.x`?** O código provavelmente está correto, mas confira [Como atualizar de `uuid@3.x`](#upgrading-from-uuid3x) obter detalhes.

## <a name="quickstart"></a>Início Rápido

Para criar um UUID aleatório...

**1. Instalar**

```shell
npm install uuid
```

**2. Criar um UUID** (sintaxe do módulo ES6)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... ou usando a sintaxe do CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Para UUIDs de carimbo de data/hora, UUIDs de namespace e outras opções leia o...

## <a name="api-summary"></a>Resumo da API

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | A cadeia de caracteres de UUID nula (todos os zeros) | Novidades no `uuid@8.3` |
| [`uuid.parse()`](#uuidparsestr) | Converter a cadeia de caracteres de UUID em uma matriz de bytes | Novidades no `uuid@8.3` |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | Converter a matriz de bytes em uma cadeia de caracteres de UUID | Novidades no `uuid@8.3` |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | Criar um UUID versão 1 (carimbo de data/hora) |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Criar um UUID versão 3 (namespace com MD5) |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | Criar um UUID versão 4 (aleatório) |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Criar um UUID versão 5 (namespace com SHA-1) |  |
| [`uuid.validate()`](#uuidvalidatestr) | Testar uma cadeia de caracteres para ver se ela é um UUID válido | Novidades no `uuid@8.3` |
| [`uuid.version()`](#uuidversionstr) | Detectar a versão de RFC de um UUID | Novidades no `uuid@8.3` |

## <a name="api"></a>API

### <a name="uuidnil"></a>uuid.NIL

A cadeia de caracteres de UUID nula (todos os zeros).

Exemplo:

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### <a name="uuidparsestr"></a>uuid.parse(str)

Converter a cadeia de caracteres de UUID em uma matriz de bytes

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | Uma `String` de UUID inválida                    |
| _retorna_ | `Uint8Array[16]`                         |
| _gera_  | `TypeError` se `str` não for uma URL válida |

Observação: a ordenação de valores nas matrizes de bytes usadas por `parse()` e `stringify()` segue a ordem esquerda &Rarr; direita dos pares hexa nas cadeias de caracteres de UUID. Como é mostrado no exemplo abaixo.

Exemplo:

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### <a name="uuidstringifyarr-offset"></a>uuid.stringify(arr[, offset])

Converter a matriz de bytes em uma cadeia de caracteres de UUID

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | Coleção de 16 valores como `Array` (começando com `offset`) entre 0 e 255. |
| [`offset` = 0] | `Number` Índice inicial na matriz                                         |
| _retorna_      | `String`                                                                     |
| _gera_       | `TypeError` se uma cadeia de caracteres de UUID válida não puder ser gerada                       |

Observação: a ordenação de valores nas matrizes de bytes usadas por `parse()` e `stringify()` segue a ordem esquerda &Rarr; direita dos pares hexa nas cadeias de caracteres de UUID. Como é mostrado no exemplo abaixo.

Exemplo:

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### <a name="uuidv1options-buffer-offset"></a>uuid.v1([options[, buffer[, offset]]])

Criar um UUID versão 1 do RFC (carimbo de data/hora)

|  |  |
| --- | --- |
| [`options`] | `Object` com uma ou mais das seguintes propriedades: |
| [`options.node` ] | Campo "node" do RFC como uma `Array[6]` de valores de bytes (de acordo com 4.1.6) |
| [`options.clockseq`] | "sequência de relógio" do RFC como um `Number` entre 0 e 0x3fff |
| [`options.msecs`] | Campo "carimbo de data/hora" do RFC (`Number` de milissegundos, época do UNIX) |
| [`options.nsecs`] | O campo "carimbo de data/hora" do RFC (`Number` de nanosegundos a serem adicionados a `msecs`, deve ser de 0 a 10.000) |
| [`options.random`] | `Array` de 16 bytes aleatórios (de 0 a 255) |
| [`options.rng`] | Alternativa a `options.random`, um `Function` que retorna uma `Array` de 16 bytes aleatórios (de 0 a 255) |
| [`buffer`] | `Array \| Buffer` Se especificado, o UUID será escrito aqui em formato de byte, começando em `offset` |
| [`offset` = 0] | `Number` Índice para começar a gravar bytes de UUID em `buffer` |
| _retorna_ | `String` de UUID quando não é especificado nenhum `buffer`, caso contrário, retorna `buffer` |
| _gera_ | `Error` quando mais de 10 M de UUIDs/s são solicitados |

Observação: A [ID de nó](https://tools.ietf.org/html/rfc4122#section-4.1.6) padrão (os últimos 12 dígitos no UUID) é gerada uma vez, aleatoriamente, na inicialização do processo e permanece inalterada durante o processo.

Observação: `options.random` e `options.rng` são significativos apenas na primeira chamada para `v1()`, em que eles podem ser passados para inicializar os campos `node` e `clockseq` internos.

Exemplo:

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

Exemplo usando `options`:

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### <a name="uuidv3name-namespace-buffer-offset"></a>uuid.v3(name, namespace[, buffer[, offset]])

Criar um UUID versão 3 (namespace com MD5) do RFC

A API é idêntica a `v5()`, mas usa "v3".

&#x26a0;&#xfe0f; Observação: De acordo com o RFC, "_Se a compatibilidade com versões anteriores não for necessária, o SHA-1 [versão 5] será preferencial_."

### <a name="uuidv4options-buffer-offset"></a>uuid.v4([options[, buffer[, offset]]])

Criar um UUID versão 4 (aleatório) do RFC

|  |  |
| --- | --- |
| [`options`] | `Object` com uma ou mais das seguintes propriedades: |
| [`options.random`] | `Array` de 16 bytes aleatórios (de 0 a 255) |
| [`options.rng`] | Alternativa a `options.random`, um `Function` que retorna uma `Array` de 16 bytes aleatórios (de 0 a 255) |
| [`buffer`] | `Array \| Buffer` Se especificado, o UUID será escrito aqui em formato de byte, começando em `offset` |
| [`offset` = 0] | `Number` Índice para começar a gravar bytes de UUID em `buffer` |
| _retorna_ | `String` de UUID quando não é especificado nenhum `buffer`, caso contrário, retorna `buffer` |

Exemplo:

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Exemplo usando valores de `random` predefinidos:

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### <a name="uuidv5name-namespace-buffer-offset"></a>uuid.v5(name, namespace[, buffer[, offset]])

Criar um UUID versão 5 (namespace com SHA-1) do RFC

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | `String \| Array[16]` UUID de namespace |
| [`buffer`] | `Array \| Buffer` Se especificado, o UUID será escrito aqui em formato de byte, começando em `offset` |
| [`offset` = 0] | `Number` Índice para começar a gravar bytes de UUID em `buffer` |
| _retorna_ | `String` de UUID quando não é especificado nenhum `buffer`, caso contrário, retorna `buffer` |

Observação: Os namespaces `DNS` e `URL` do RFC estão disponíveis como `v5.DNS` e `v5.URL`.

Exemplo com namespace personalizado:

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

Exemplo com namespace `URL` do RFC:

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### <a name="uuidvalidatestr"></a>uuid.validate(str)

Testar uma cadeia de caracteres para ver se ela é um UUID válido

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | `String` a ser validada                                |
| _retorna_ | `true` quando a cadeia de caracteres é um UUID válido, caso contrário, `false` |

Exemplo:

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

Usando `validate` e `version` juntos, é possível fazer a validação por versão. Por exemplo, validar apenas os UUIDs v4.

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### <a name="uuidversionstr"></a>uuid.version(str)

Detectar a versão de RFC de um UUID

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | Uma `String` de UUID inválida                    |
| _retorna_ | `Number` A versão do RFC do UUID     |
| _gera_  | `TypeError` se `str` não for uma URL válida |

Exemplo:

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## <a name="command-line"></a>Linha de Comando

Os UUIDs podem ser gerados pela linha de comando usando `uuid`.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

O padrão é gerar a UUIDs versão 4. Mas há suporte para as outras versões. Digite `uuid --help` para obter detalhes:

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## <a name="ecmascript-modules"></a>Módulos ECMAScript

Essa biblioteca vem com suporte de [Módulos ECMAScript](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (EMS) para as versões do Node.js compatíveis com ela ([exemplo](./examples/node-esmodules/)), bem como empacotadores como [rollup.js](https://rollupjs.org/guide/en/#tree-shaking) ([exemplo](./examples/browser-rollup/)) e [Webpack](https://webpack.js.org/guides/tree-shaking/) ([exemplo](./examples/browser-webpack/)) (com ambientes de destino do Node.js e do navegador).

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Para executar os exemplos, primeiro você precisa criar um build dist dessa biblioteca na raiz do módulo:

```shell
npm run build
```

## <a name="cdn-builds"></a>Builds de CDN

### <a name="ecmascript-modules"></a>Módulos ECMAScript

Para carregar este módulo diretamente em navegadores modernos que [dão suporte ao carregamento de módulos ECMAScript](https://caniuse.com/#feat=es6-module), você pode usar o [jspm](https://jspm.org/):

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### <a name="umd"></a>UMD

Para carregar este módulo diretamente em navegadores mais antigos, você pode usar os builds [UMD (Universal Module Definition)](https://github.com/umdjs/umd) de qualquer uma das seguintes CDNs:

**Usando [UNPKG](https://unpkg.com/uuid@latest/dist/umd/)** :

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Usando [jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)** :

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Usando [cdnjs](https://cdnjs.com/libraries/uuid)** :

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

Todas essas CDNs fornecem o mesmo método [`uuidv4()`](#uuidv4options-buffer-offset):

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

Os métodos para os outros algoritmos ([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) e [`uuidv5()`](#uuidv5name-namespace-buffer-offset)) estão disponíveis nos arquivos `uuidv1.min.js`, `uuidv3.min.js` e `uuidv5.min.js` respectivamente.

## <a name="getrandomvalues-not-supported"></a>"getRandomValues() not supported"

Esse erro ocorre em ambientes em que não há suporte para a API [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) padrão. Esse problema pode ser resolvido adicionando um polyfill apropriado:

### <a name="react-native--expo"></a>React Native/Expo

1. Instale o [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)
1. Importe-o _antes_ de `uuid`. Como `uuid` também pode aparecer como uma dependência transitiva de algumas outras importações, é mais seguro importar `react-native-get-random-values` logo como a primeira coisa no ponto de entrada:

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

Observação: se você estiver usando o Expo, use pelo menos `react-native-get-random-values@1.5.0` e `expo@39.0.0`.

### <a name="web-workers--service-workers-edge--18"></a>Funções de trabalho/trabalhos de serviço (Edge <= 18)

[No Edge <= 18, não há suporte para criptografia da Web em funções de trabalho ou trabalhos de serviço](https://caniuse.com/#feat=cryptography) e não conhecemos um polyfill (informe-nos se você encontrar algum).

## <a name="upgrading-from-uuid7x"></a>Atualização de `uuid@7.x`

### <a name="only-named-exports-supported-when-using-with-nodejs-esm"></a>Somente exportações nomeadas com suporte usadas com o Node.js ESM

`uuid@7.x` não veio com suporte nativo ao ESM (Módulo ECMAScript) para Node.js. A importação no Node.js ESM fez com que a fonte CommonJS fosse importada com uma exportação padrão. Essa biblioteca agora vem com suporte verdadeiro ao Node.js ESM e fornece apenas exportações nomeadas.

Em vez de executar:

```javascript
import uuid from 'uuid';
uuid.v4();
```

agora você terá que usar as exportações nomeadas:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### <a name="deep-requires-no-longer-supported"></a>Não há mais suporte para requisitos aprofundados

Não há mais suporte para requisitos aprofundados como `require('uuid/v4')` [foram preteridas em `uuid@7.x`](#deep-requires-now-deprecated).

## <a name="upgrading-from-uuid3x"></a>Atualização de `uuid@3.x`

"_Espera, o que aconteceu com o `uuid@4.x` - `uuid@6.x`?!?_ "

Para evitar confusão com os UUIDs [versão 4](#uuidv4options-buffer-offset) e [5](#uuidv5name-namespace-buffer-offset) do RFC e uma possível [versão 6](http://gh.peabody.io/uuidv6/), as versões 4 a 6 deste módulo foram ignoradas.

### <a name="deep-requires-now-deprecated"></a>Os requisitos aprofundados foram preteridos

O `uuid@3.x` incentiva o uso de requisitos aprofundados para minimizar o tamanho do pacote dos builds do navegador:

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

Do `uuid@7.x` em diante, essa biblioteca, agora fornece builds de módulos ECMAScript, que permitem que empacotadores como Webpack e Rollup façam "agitação de árvore" para remover o código morto. Nesse caso, use a sintaxe `import`:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... ou para CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### <a name="default-export-removed"></a>Exportação padrão removida

O `uuid@3.x` exportava o método UUID versão 4 como uma exportação padrão:

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

Esse padrão de uso já foi desencorajado no `uuid@3.x` e removido no `uuid@7.x`.

----
Markdown gerado do [README_js.md](README_js.md) pela [![logotipo do RunMD](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd)