---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052937"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![downloads][downloads-image]][downloads-url] [![javascript style guide][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>API de Buffer do Node.js mais segura

**Use as novas APIs de Buffer do Node.js (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe` e `Buffer.allocUnsafeSlow`) em todas as versões do Node.js.**

**Usa a implementação interna quando disponível.**

## <a name="install"></a>instalar

```
npm install safe-buffer
```

## <a name="usage"></a>uso

A meta deste pacote é fornecer uma substituição segura ao `Buffer` do Node.js.

É uma substituição imediata do `Buffer`. Você pode usá-la adicionando uma linha `require` à parte superior dos módulos do Node.js:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Método de classe: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Matriz}

Aloca um novo `Buffer` usando um `array` de octetos.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

Um `TypeError` será gerado se `array` não for um `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Método de classe: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} A propriedade `.buffer` de um `TypedArray` ou um `new ArrayBuffer()`
* `byteOffset` {Número} Padrão: `0`
* `length` {Número} Padrão: `arrayBuffer.length - byteOffset`

Quando for passada uma referência à propriedade `.buffer` de uma instância `TypedArray`, o `Buffer` recém-criado compartilhará a mesma memória alocada que o TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Os argumentos opcionais `byteOffset` e `length` especificam um intervalo de memória dentro de `arrayBuffer` que será compartilhado pelo `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

Um `TypeError` será gerado se `arrayBuffer` não for um `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Método de classe: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Copia os dados de `buffer` passados para uma nova instância de `Buffer`.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

Um `TypeError` será gerado se `buffer` não for um `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Método de classe: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {Cadeia de caracteres} A cadeia de caracteres a ser codificada.
* `encoding` {Cadeia de caracteres} Codificação a ser usada, Padrão: `'utf8'`

Cria um `Buffer` que contém a cadeia de caracteres JavaScript `str` fornecida. Se fornecido, o parâmetro `encoding` identificará a codificação de caracteres.
Se não for fornecido, o padrão de `encoding` será `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

Um `TypeError` será gerado se `str` não for uma cadeia de caracteres.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Método de classe: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Número}
* `fill` {Valor} Padrão: `undefined`
* `encoding` {Cadeia de caracteres} Padrão: `utf8`

Aloca um novo `Buffer` de `size` bytes. Se `fill` for `undefined`, o `Buffer` será *preenchido por zero*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

O `size` precisa ser igual ou inferior ao valor de `require('buffer').kMaxLength` (em arquiteturas de 64 bits, `kMaxLength` é `(2^31)-1`). Caso contrário, um [`RangeError`][] será gerado. Um Buffer de comprimento zero será criado se um `size` igual ou inferior a 0 for especificado.

Se `fill` for especificado, o `Buffer` alocado será inicializado chamando `buf.fill(fill)`. Confira [`buf.fill()`][] para obter mais informações.

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Se `fill` e `encoding` forem especificados, o `Buffer` alocado será inicializado chamando `buf.fill(fill, encoding)`. Por exemplo:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

A chamada de `Buffer.alloc(size)` pode ser significativamente mais lenta do que a alternativa `Buffer.allocUnsafe(size)`, mas garante que o conteúdo da instância `Buffer` recém-criado *nunca contenha dados confidenciais*.

Um `TypeError` será gerado se `size` não for um número.

### <a name="class-method-bufferallocunsafesize"></a>Método de classe: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Número}

Aloca um novo `Buffer` *não preenchido por zero* de `size` bytes.  O `size` precisa ser igual ou inferior ao valor de `require('buffer').kMaxLength` (em arquiteturas de 64 bits, `kMaxLength` é `(2^31)-1`). Caso contrário, um [`RangeError`][] será gerado. Um Buffer de comprimento zero será criado se um `size` igual ou inferior a 0 for especificado.

A memória subjacente de instâncias de `Buffer` criadas dessa forma *não é inicializada*. O conteúdo do `Buffer` recém-criado é desconhecido e *pode conter dados confidenciais*. Use [`buf.fill(0)`][] para inicializar essas instâncias de `Buffer` como zeros.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Um `TypeError` será gerado se `size` não for um número.

Observe que o módulo `Buffer` aloca previamente uma instância `Buffer` interna de tamanho `Buffer.poolSize` que é usada como um pool para a alocação rápida de novas instâncias de `Buffer` criadas usando `Buffer.allocUnsafe(size)` (e o construtor `new Buffer(size)` preterido) somente quando `size` é igual ou inferior a `Buffer.poolSize >> 1` (base de `Buffer.poolSize` dividido por dois). O valor padrão de `Buffer.poolSize` é `8192`, mas pode ser modificado.

O uso desse pool de memória interno pré-alocado é uma diferença importante entre chamar `Buffer.alloc(size, fill)` e `Buffer.allocUnsafe(size).fill(fill)`. Especificamente, `Buffer.alloc(size, fill)` *nunca* usará o pool de Buffer interno, mas `Buffer.allocUnsafe(size).fill(fill)` *usará* o pool de Buffer interno se `size` for igual ou inferior à metade de `Buffer.poolSize`. A diferença é sutil, mas pode ser importante quando um aplicativo precisa do desempenho adicional que `Buffer.allocUnsafe(size)` oferece.

### <a name="class-method-bufferallocunsafeslowsize"></a>Método de classe: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Número}

Aloca um novo `Buffer` *não preenchido por zero* e sem pool de `size` bytes.  O `size` precisa ser igual ou inferior ao valor de `require('buffer').kMaxLength` (em arquiteturas de 64 bits, `kMaxLength` é `(2^31)-1`). Caso contrário, um [`RangeError`][] será gerado. Um Buffer de comprimento zero será criado se um `size` igual ou inferior a 0 for especificado.

A memória subjacente de instâncias de `Buffer` criadas dessa forma *não é inicializada*. O conteúdo do `Buffer` recém-criado é desconhecido e *pode conter dados confidenciais*. Use [`buf.fill(0)`][] para inicializar essas instâncias de `Buffer` como zeros.

Quando `Buffer.allocUnsafe()` é usado para alocar novas instâncias de `Buffer`, as alocações abaixo de 4 KB são, por padrão, fatiadas de um só `Buffer` pré-alocado. Isso permite que os aplicativos evitem a sobrecarga da coleta de lixo de criar vários Buffers alocados individualmente. Essa abordagem aprimora o desempenho e o uso de memória eliminando a necessidade de acompanhar e limpar tantos objetos `Persistent`.

No entanto, quando o desenvolvedor precisar reter uma pequena parte da memória de um pool por um período de tempo indeterminado, ele poderá criar uma instância de Buffer sem pool usando `Buffer.allocUnsafeSlow()` e depois copiar os bits relevantes.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()` deve ser usado apenas como último recurso *depois* que o desenvolvedor observar uma retenção de memória indevida nos aplicativos.

Um `TypeError` será gerado se `size` não for um número.

### <a name="all-the-rest"></a>Todo o restante

O restante da API `Buffer` é exatamente o mesmo que no Node.js.
[Confira a documentação](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Links relacionados

- [Problema do Node.js: Buffer(number) não é seguro](https://github.com/nodejs/node/issues/4660)
- [Proposta de aprimoramento do Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Por que `Buffer` não é seguro?

Hoje, o construtor node.js `Buffer` está sobrecarregado para processar vários tipos de argumentos diferentes, como `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array` etc.), `ArrayBuffer` e também `Number`.

A API foi otimizada para facilitar o processo: forneça qualquer tipo e ela tentará fazer o que você quer.

Como o construtor Buffer é altamente eficiente, o código geralmente fica assim:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Mas o que acontece quando `toHex` é chamado com um argumento `Number`?***

### <a name="remote-memory-disclosure"></a>Divulgação de memória remota

Se um invasor puder fazer o programa chamar o construtor `Buffer` com um argumento `Number`, ele poderá fazer com que ele aloque a memória não inicializada do processo do Node.js.
Isso poderá divulgar chaves privadas TLS, dados do usuário ou senhas de banco de dados.

Quando o construtor `Buffer` recebe um argumento `Number`, ele retorna um bloco de memória **UNINITIALIZED** do `size` especificado. Ao criar um `Buffer` como esse, você **PRECISA** substituir o conteúdo antes de retorná-lo ao usuário.

Na [documentação do Node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - `size` Number
>
> A memória subjacente de instâncias de `Buffer` criadas dessa forma não é inicializada.
> **O conteúdo de um `Buffer` recém-criado é desconhecido e pode conter dados confidenciais.** Use `buf.fill(0)` para inicializar um Buffer como zeros.

(Enfatize o nosso.)

Sempre que o programador pretende criar um `Buffer` não inicializado, o código geralmente fica assim:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>Isso seria um problema no código real?

Sim. É mais comum do que parece esquecer de verificar o tipo das variáveis em uma linguagem de tipo dinâmico, como JavaScript.

Geralmente, as consequências de assumir o tipo errado é que o programa falha com uma exceção não capturada. Mas o modo de falha para esquecer de verificar o tipo de argumentos do construtor `Buffer` é mais grave.

Veja um exemplo de um serviço vulnerável que pega uma carga JSON e converte-a em hexadecimal:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

Neste exemplo, um cliente http só precisa enviar:

```json
{
  "str": 1000
}
```

e ele receberá de volta 1.000 bytes de memória não inicializada do servidor.

Esse é um bug muito sério. Esse bug tem a mesma gravidade que o [bug Heartbleed](http://heartbleed.com/) que permitiu a divulgação da memória do processo OpenSSL a invasores remotos.


### <a name="which-real-world-packages-were-vulnerable"></a>Quais pacotes do mundo real ficaram vulneráveis?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) e eu ([Feross Aboukhadijeh](http://feross.org/)) encontramos esse problema em um dos nossos pacotes, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). O bug permitiria que qualquer pessoa na Internet enviasse uma série de mensagens a um usuário do `bittorrent-dht`, fazendo-o revelar 20 bytes por vez de memória não inicializada do processo do Node.js.

Veja o [commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) que corrigiu isso. Lançamos uma nova versão fixa, criamos uma [divulgação do Node Security Project](https://nodesecurity.io/advisories/68) e preterimos todas as versões vulneráveis no npm para que os usuários obtivessem um aviso de atualização para uma versão mais recente.

#### [`ws`](https://www.npmjs.com/package/ws)

Isso nos fez pensar se havia outros pacotes vulneráveis. Com certeza, em um curto período de tempo, encontramos o mesmo problema no [`ws`](https://www.npmjs.com/package/ws), a implementação mais popular do WebSocket no Node.js.

Se determinadas APIs fossem chamadas com parâmetros `Number` em vez de `String` ou `Buffer` que seria o esperado, a memória do servidor não inicializada seria divulgada ao par remoto.

Estes eram os métodos vulneráveis:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Veja um servidor de soquete vulnerável com algumas funcionalidades de eco:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

`socket.send(number)` chamado no servidor, divulga a memória do servidor.

Veja [a versão](https://github.com/websockets/ws/releases/tag/1.0.1) em que o problema foi corrigido, com uma explicação mais detalhada. Proposta de correção rápida para [Arnout Kazemier](https://github.com/3rd-Eden). Veja a [divulgação do Node Security Project](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Qual é a solução?

É importante que o Node.js ofereça um modo rápido de obter memória, caso contrário, aplicativos de desempenho crítico ficariam muito lentos sem necessidade.

Mas precisamos de uma forma melhor de *sinalizar nossa intenção* enquanto programadores. **Quando queremos memória não inicializada, devemos solicitá-la explicitamente.**

A funcionalidade confidencial não deve ser empacotada em uma API amigável para desenvolvedores que aceite livremente vários tipos diferentes. Esse tipo de API incentiva a prática lenta de passar variáveis sem verificar o tipo com o cuidado necessário.

#### <a name="a-new-api-bufferallocunsafenumber"></a>Uma nova API: `Buffer.allocUnsafe(number)`

A funcionalidade de criação de buffers com memória não inicializada deve fazer parte de outra API. Nossa proposta é a `Buffer.allocUnsafe(number)`. Assim, essa função não faz parte de uma API que recebe entradas frequentes do usuário de diversos tipos diferentes.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Como corrigir o Node.js Core?

Enviamos [uma PR ao Node.js Core](https://github.com/nodejs/node/pull/4514) (mesclada como `semver-major`) que faz a defesa contra um caso:

```js
var str = 16
new Buffer(str, 'utf8')
```

Nessa situação, é implícito que o programador pretendia que o primeiro argumento fosse uma cadeia de caracteres, pois ele passou uma codificação como um segundo argumento. Hoje, o Node.js alocará a memória não inicializada em caso de `new Buffer(number, encoding)`, que provavelmente não é o que o programador pretendia.

Mas essa é apenas uma solução parcial, pois se o programador fizer `new Buffer(variable)` (sem um parâmetro `encoding`) não haverá como saber o que ele pretendia. Se ocasionalmente `variable` for um número, a memória não inicializada poderá ser retornada.

### <a name="whats-the-real-long-term-fix"></a>Qual é a verdadeira correção de longo prazo?

Podemos preterir e remover `new Buffer(number)` e usar `Buffer.allocUnsafe(number)` quando precisarmos de memória não inicializada. Mas isso interromperia milhares de pacotes.

~~Acreditamos que a melhor solução é:~~

~~1. Alterar `new Buffer(number)` para retornar memória segura e sem zeros~~

~~2. Criar uma API para criar Buffers não inicializados. Nossa proposta: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Atualizar

Agora, damos suporte à adição das três APIs novas:

- `Buffer.from(value)` – Converter qualquer tipo em um buffer
- `Buffer.alloc(size)` – Criar um buffer preenchido por zero
- `Buffer.allocUnsafe(size)` – Criar um buffer não inicializado com um tamanho determinado

Isso resolve o problema principal que afetou o `ws` e o `bittorrent-dht`, em que o `Buffer(variable)` era enganado ao receber um argumento numérico.

Dessa forma, o código existente continua funcionando e o impacto no ecossistema do npm é mínimo. Ao longo do tempo, os mantenedores do npm podem migrar o código de desempenho crítico para usar `Buffer.allocUnsafe(number)` em vez de `new Buffer(number)`.


### <a name="conclusion"></a>Conclusão

Consideramos que há um problema sério de design com a API `Buffer` da forma que ela existe hoje. Esse problema promove a falta de segurança do software colocando funcionalidades de alto risco em uma API fácil de usar e amigável para os desenvolvedores.

Esse não foi apenas um exercício teórico porque encontramos o problema em alguns dos pacotes npm mais populares.

Felizmente, há uma correção fácil que pode ser aplicada hoje. Usar `safe-buffer` no lugar de `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

Esperamos que finalmente o Node.js Core possa migrar para esse novo comportamento mais seguro. Acreditamos que o impacto no ecossistema seria mínimo, pois essa não é uma alteração interruptiva.
Pacotes populares mantidos do modo certo seriam atualizados para usar `Buffer.alloc` rapidamente, enquanto os pacotes mais antigos e não seguros ficariam protegidos contra esse vetor de ataque magicamente.


## <a name="links"></a>links

- [PR do Node.js: buffer: gerar se o comprimento e a codificação forem passados](https://github.com/nodejs/node/pull/4514)
- [Divulgação do Node Security Project para `ws`](https://nodesecurity.io/advisories/67)
- [Divulgação do Node Security Project para o `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>crédito

Os problemas originais em `bittorrent-dht` ([divulgação](https://nodesecurity.io/advisories/68)) e `ws` ([divulgação](https://nodesecurity.io/advisories/67)) foram descobertos por [Mathias Buus](https://github.com/mafintosh) e [Feross Aboukhadijeh](http://feross.org/).

Agradecemos o [Adam Baldwin](https://github.com/evilpacket) por ajudar a divulgar esses problemas e pelo trabalho que ele teve executando o [Node Security Project](https://nodesecurity.io/).

Agradecemos ao [John Hiesey](https://github.com/jhiesey) pela revisão desse LEIAME e pela audição do código.


## <a name="license"></a>license

MIT. Direitos autorais (C) [Feross Aboukhadijeh](http://feross.org)
