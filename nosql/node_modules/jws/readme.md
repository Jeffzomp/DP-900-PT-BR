---
ms.openlocfilehash: 4d20fe9ebd12ad861676f14f1c8e66479fd1e481
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050220"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![Status de build](https://secure.travis-ci.org/brianloveswords/node-jws.svg)](http://travis-ci.org/brianloveswords/node-jws)

Uma implementação de [Assinaturas Web JSON](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Foi desenvolvido em relação a `draft-ietf-jose-json-web-signature-08` e implementa toda a especificação, **exceto** assinatura/verificação da cadeia de certificados X.509 (patches são bem-vindos).

Há APIs síncronas (`jws.sign`, `jws.verify`) e de streaming (`jws.createSign`, `jws.createVerify`).

# <a name="install"></a>Instalar

```bash
$ npm install jws
```

# <a name="usage"></a>Uso

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Matriz de algoritmos com suporte. No momento, há suporte para os algoritmos a seguir.

Valor de parâmetro do algoritmo | Algoritmo de Assinatura Digital ou MAC
----------------|----------------------------
HS256 | Algoritmo HMAC usando o hash SHA-256
HS384 | Algoritmo HMAC usando o hash SHA-384
HS512 | Algoritmo HMAC usando o hash SHA-512
RS256 | Algoritmo RSASSA usando o hash SHA-256
RS384 | Algoritmo RSASSA usando o hash SHA-384
RS512 | Algoritmo RSASSA usando o hash SHA-512
PS256 | Algoritmo RSASSA-PSS usando o hash SHA-256
PS384 | Algoritmo RSASSA-PSS usando o hash SHA-384
PS512 | Algoritmo RSASSA-PSS usando o hash SHA-512
ES256 | Algoritmo ECDSA usando a curva P-256 e o hash SHA-256
ES384 | Algoritmo ECDSA usando a curva P-384 e o hash SHA-384
ES512 | Algoritmo ECDSA usando a curva P-521 e o hash SHA-512
nenhum | Não incluído nenhum valor de assinatura digital ou de MAC

## <a name="jwssignoptions"></a>jws.sign(options)

(Síncrono) Retornar uma Assinatura Web JSON para um cabeçalho e um conteúdo.

Opções:

* `header`
* `payload`
* `secret` ou `privateKey`
* `encoding` (Opcional, o padrão é 'utf8')

`header` precisa ser um objeto com uma propriedade `alg`. `header.alg` precisa ser um valor encontrado em `jws.ALGORITHMS`. Confira acima uma tabela de algoritmos com suporte.

Se o `payload` não for um buffer nem uma cadeia de caracteres, ele será convertido em cadeia de caracteres usando `JSON.stringify`.

Exemplo

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(Síncrono) Retorna `true` ou `false` quando uma assinatura corresponde a um segredo ou uma chave.

`signature` é uma assinatura JWS. `header.alg` precisa ser um valor encontrado em `jws.ALGORITHMS`.
Confira acima uma tabela de algoritmos com suporte. `secretOrKey` é uma cadeia de caracteres ou um buffer que contém o segredo dos algoritmos HMAC ou a chave privada codificada em PEM para RSA e ECDSA.

Observe que o valor de `"alg"` do cabeçalho de assinatura é ignorado.


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(Síncrono) Retorna o cabeçalho decodificado, o conteúdo decodificado e as partes de assinatura da Assinatura JWS.

Retorna um objeto com três propriedades, por exemplo,
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

Retorna um novo objeto SignStream.

Opções:

* `header` (obrigatório)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Opcional, o padrão é 'utf8')

Além de `header`, todas as opções esperam uma cadeia de caracteres ou um buffer quando o valor é conhecido com antecedência ou um fluxo para conveniência.
`key`/`privateKey`/`secret` também pode ser um objeto ao usar uma chave privada criptografada. Confira a [documentação de criptografia][encrypted-key-docs].

Exemplo:

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

Retorna um novo objeto VerifyStream.

Opções:

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Opcional, o padrão é 'utf8')

Todas as opções esperam uma cadeia de caracteres ou um buffer quando o valor é conhecido com antecedência ou um fluxo por conveniência.

Exemplo:

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Classe: SignStream

Um `Readable Stream` que emite um só evento de dados (a assinatura calculada) quando concluído.

### <a name="event-done"></a>Evento: 'done'
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

Um `Writable Stream` que espera o conteúdo da JWS. *Não* use se você passou uma opção `payload` para o construtor.

Exemplo:

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

Uma `Writable Stream`. Espera o segredo da JWS para HMAC ou a privateKey para ECDSA e RSA. *Não* use se você passou uma opção `secret` ou `key` para o construtor.

Exemplo:

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Classe: VerifyStream

É um `Readable Stream` que emite um só evento de dados, indicando se essa assinatura era válida ou não.

### <a name="event-done"></a>Evento: 'done'
`function (valid, obj) { }`

`valid` é um booliano para saber se a assinatura é válida ou não.

### <a name="verifiersignature"></a>verifier.signature

Um `Writable Stream` que espera uma assinatura JWS. *Não* use se você passou uma opção `signature` para o construtor.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

Um `Writable Stream` que espera uma chave pública ou um segredo. *Não* use se você passou uma opção `key` ou `secret` para o construtor.

# <a name="todo"></a>TODO

* Parece que precisa haver algumas opções/APIs de conveniência para definir o algoritmo para que não seja sempre necessário definir um objeto de cabeçalho com `{ alg: 'ES512' }` ou fazer alguma outra coisa.

* Suporte a X.509

# <a name="license"></a>Licença

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
