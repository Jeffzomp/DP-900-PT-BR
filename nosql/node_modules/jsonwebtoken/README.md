---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050309"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Compilar** | **Dependência** |
|-----------|---------------|
| [![Status de build](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Status da dependência](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Uma implementação de [Tokens Web JSON](https://tools.ietf.org/html/rfc7519).

Ela foi desenvolvida em relação a `draft-ietf-oauth-json-web-token-08`. Ela usa o [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>Instalar

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Notas de migração

* [De v7 a v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Uso

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Assíncrono) Se um retorno de chamada for fornecido, ele será chamado com o `err` ou o JWT.

(Síncrono) Retorna o JsonWebToken como cadeia de caracteres

`payload` pode ser um objeto literal, um buffer ou uma cadeia de caracteres que representa um JSON válido. 
> **_Observe_ que** `exp` ou qualquer outra declaração só será definida se o conteúdo for um literal de objeto. Os conteúdos de buffer ou de cadeia de caracteres não são verificados quanto à validade do JSON.

> Se o `payload` não for um buffer nem uma cadeia de caracteres, ele será convertido em cadeia de caracteres usando `JSON.stringify`.

`secretOrPrivateKey` é uma cadeia de caracteres, um buffer ou um objeto que contém o segredo para algoritmos HMAC ou a chave privada codificada em PEM para RSA e ECDSA. No caso de uma chave privada com frase secreta, um objeto `{ key, passphrase }` pode ser usado (com base na [documentação de criptografia](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)). Nesse caso, passe a opção `algorithm`.

`options`:

* `algorithm` (padrão: `HS256`)
* `expiresIn`: expresso em segundos ou uma cadeia de caracteres que descreve um período de tempo [zeit/ms](https://github.com/zeit/ms). 
  > Exemplo: `60`, `"2 days"`, `"10h"` e `"7d"`. Um valor numérico é interpretado como uma contagem de segundos. Se você usar uma cadeia de caracteres, forneça as unidades de tempo (dias, horas etc.). Caso contrário, a unidade de milissegundos será usada por padrão (`"120"` é igual a `"120ms"`).
* `notBefore`: expresso em segundos ou uma cadeia de caracteres que descreve um período de tempo [zeit/ms](https://github.com/zeit/ms). 
  > Exemplo: `60`, `"2 days"`, `"10h"` e `"7d"`. Um valor numérico é interpretado como uma contagem de segundos. Se você usar uma cadeia de caracteres, forneça as unidades de tempo (dias, horas etc.). Caso contrário, a unidade de milissegundos será usada por padrão (`"120"` é igual a `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: se for true, a função de sinal modificará o objeto de conteúdo diretamente. Essa opção será útil se você precisar de uma referência bruta ao conteúdo depois que as declarações forem aplicadas a ele, mas antes que ele seja codificado em um token.



> Não há valores padrão para `expiresIn`, `notBefore`, `audience`, `subject`e `issuer`.  Essas declarações também podem ser fornecidas no conteúdo diretamente com `exp`, `nbf`, `aud`, `sub` e `iss` respectivamente, mas você **_não pode_** incluí-las em ambos os locais.

Lembre-se de que `exp`, `nbf` e `iat` são **NumericDate**. Confira a seção relacionada [Expiração de token (declaração exp)](#token-expiration-exp-claim)


O cabeçalho pode ser personalizado por meio do objeto `options.header`.

Os jwts gerados incluirão uma declaração `iat` (emitida em) por padrão, a menos que o `noTimestamp` seja especificado. Se `iat` for inserido no conteúdo, ele será usado em vez do carimbo de data/hora real para calcular outras coisas, como `exp` dado um período de tempo em `options.expiresIn`.

Assinatura síncrona com padrão (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Assinatura síncrona com RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Assinar de maneira assíncrona
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Retroceder um JWT em 30 segundos
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Expiração do token (declaração exp)

O padrão para o JWT define uma declaração `exp` de expiração. A expiração é representada como um **NumericDate**:

> Um valor numérico JSON que representa o número de segundos de 1970-01-01T00:00:00Z UTC até a data/hora UTC especificada, ignorando os segundos bissextos.  Isso é equivalente à definição "Seconds Since the Epoch" do IEEE Std 1003.1, 2013 Edition [POSIX.1], em que cada dia é contabilizado em exatamente 86400 segundos e além desse valor nenhum inteiro pode ser representado.  Confira o RFC 3339 [RFC3339] para obter detalhes sobre data/hora em geral e UTC especificamente.

Isso significa que o campo `exp` deve conter o número de segundos desde a época.

Assinatura de um token com 1 hora de expiração:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Outra maneira de gerar um token como esse com essa biblioteca é:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Assíncrono) Se um retorno de chamada for fornecido, a função atuará de maneira assíncrona. O retorno de chamada será chamado com o conteúdo decodificado se a assinatura for válida e a expiração, o público-alvo ou o emissor opcionais forem válidos. Caso contrário, ele será chamado com o erro.

(Síncrono) Se um retorno de chamada não for fornecido, a função agirá de maneira síncrona. Retornará o conteúdo decodificado se a assinatura for válida e se a expiração, o público-alvo ou o emissor opcionais forem válidos. Caso contrário, ele vai gerar o erro.

`token` é a cadeia de caracteres do JsonWebToken

`secretOrPublicKey` é uma cadeia de caracteres ou um buffer que contém o segredo dos algoritmos HMAC ou a chave privada codificada em PEM para RSA e ECDSA.
Se `jwt.verify` for chamado de modo assíncrono, `secretOrPublicKey` poderá ser uma função que deve buscar o segredo ou a chave pública. Veja abaixo um exemplo detalhado

Como mencionado [neste comentário](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), há outras bibliotecas que esperam segredos codificados em Base64 (bytes aleatórios codificados usando Base64). Se esse for seu caso, passe `Buffer.from(secret, 'base64')`, para que o segredo seja decodificado usando Base64 e a verificação de token use os bytes aleatórios originais.

`options`

* `algorithms`: Lista de cadeias de caracteres com os nomes dos algoritmos permitidos. Por exemplo, `["HS256", "HS384"]`.
* `audience`: se você quiser verificar o público-alvo (`aud`), forneça um valor aqui. O público-alvo pode ser verificado em uma cadeia de caracteres, uma expressão regular ou uma lista de cadeias de caracteres e/ou expressões regulares. 
  > Exemplo: `"urn:foo"`, `/urn:f[o]{2}/` e `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: retornar um objeto com o `{ payload, header, signature }` decodificado em vez de apenas os dados usuais do conteúdo.
* `issuer` (opcional): cadeia de caracteres ou matriz de cadeias de caracteres de valores válidos para o campo `iss`.
* `ignoreExpiration`: se `true` não validar a expiração do token.
* `ignoreNotBefore`...
* `subject`: se você quiser verificar a entidade (`sub`), forneça um valor aqui
* `clockTolerance`: número de segundos de tolerância ao verificar as declarações `nbf` e `exp`, para lidar com pequenas diferenças de relógio entre diferentes servidores
* `maxAge`: a duração máxima permitida para que os tokens ainda sejam válidos. Expresso em segundos ou como uma cadeia de caracteres que descreve um período de tempo [zeit/ms](https://github.com/zeit/ms). 
  > Exemplo: `1000`, `"2 days"`, `"10h"` e `"7d"`. Um valor numérico é interpretado como uma contagem de segundos. Se você usar uma cadeia de caracteres, forneça as unidades de tempo (dias, horas etc.). Caso contrário, a unidade de milissegundos será usada por padrão (`"120"` é igual a `"120ms"`).
* `clockTimestamp`: o tempo em segundos que deve ser usado como o tempo atual para todas as comparações necessárias.
* `nonce`: se você quiser verificar a declaração `nonce`, forneça um valor de cadeia de caracteres aqui. Ele é usado no OpenID para tokens de ID. ([Notas de implementação do OpenID](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Síncrono) Retorna o conteúdo decodificado sem verificar se a assinatura é válida.

> __Aviso__: essa opção __não__ verifica se a assinatura é válida. Você __não__ deve usá-la para mensagens não confiáveis. É melhor usar `jwt.verify` nesse caso.

`token` é a cadeia de caracteres do JsonWebToken

`options`:

* `json`: forçar JSON.parse no conteúdo mesmo se o cabeçalho não contiver `"typ":"JWT"`.
* `complete`: retornar um objeto com o conteúdo e o cabeçalho decodificados.

Exemplo

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Erros e códigos
Possíveis erros gerados durante a verificação.
O erro é o primeiro argumento do retorno de chamada da verificação.

### <a name="tokenexpirederror"></a>TokenExpiredError

Erro gerado quando o token está expirado.

Objeto do erro:

* nome: 'TokenExpiredError'
* mensagem: 'jwt expired'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Objeto do erro:

* nome: 'JsonWebTokenError'
* mensagem:
  * 'jwt malformed'
  * 'jwt signature is required'
  * 'invalid signature'
  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]'
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'
  * 'jwt id invalid. expected: [OPTIONS JWT ID]'
  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Gerado se a hora atual for anterior à declaração nbf.

Objeto do erro:

* nome: 'NotBeforeError'
* message: 'jwt not active'
* date: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Algoritmos com suporte

Matriz de algoritmos com suporte. No momento, há suporte para os algoritmos a seguir.

Valor de parâmetro do algoritmo | Algoritmo de Assinatura Digital ou MAC
----------------|----------------------------
HS256 | Algoritmo HMAC usando o hash SHA-256
HS384 | Algoritmo HMAC usando o hash SHA-384
HS512 | Algoritmo HMAC usando o hash SHA-512
RS256 | Algoritmo RSASSA-PKCS1-v1_5 usando SHA-256
RS384 | Algoritmo RSASSA-PKCS1-v1_5 usando SHA-384
RS512 | Algoritmo RSASSA-PKCS1-v1_5 usando SHA-512
PS256 | Algoritmo RSASSA-PSS usando o hash SHA-256 (somente no Node ^ 6.12.0 ou >= 8.0.0)
PS384 | Algoritmo RSASSA-PSS usando o hash SHA-384 (somente no Node ^ 6.12.0 ou >= 8.0.0)
PS512 | Algoritmo RSASSA-PSS usando o hash SHA-512 (somente no Node ^ 6.12.0 ou >= 8.0.0)
ES256 | Algoritmo ECDSA usando a curva P-256 e o hash SHA-256
ES384 | Algoritmo ECDSA usando a curva P-384 e o hash SHA-384
ES512 | Algoritmo ECDSA usando a curva P-521 e o hash SHA-512
nenhum | Não incluído nenhum valor de assinatura digital ou de MAC

## <a name="refreshing-jwts"></a>Atualização de JWTs

Em primeiro lugar, recomendamos que você pense com atenção se a atualização automática de um JWT não introduzirá nenhuma vulnerabilidade no sistema.

Não estamos seguros para incluir essa opção na biblioteca, mas você pode dar uma olhada [neste exemplo](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) para saber como isso poderia ser feito.
Além desse exemplo, há [um problema](https://github.com/auth0/node-jsonwebtoken/issues/122) e [uma solicitação de pull](https://github.com/auth0/node-jsonwebtoken/pull/172) para saber mais sobre esse tópico.

# <a name="todo"></a>TODO

* A cadeia de certificados X.509 não é verificada

## <a name="issue-reporting"></a> Relatório de Problemas 

Se você encontrou um bug ou tem uma solicitação de recurso, relate isso nesta seção de problemas do repositório. Não relate vulnerabilidades de segurança no acompanhamento público de problemas do GitHub. O [Programa de Divulgação Responsável](https://auth0.com/whitehat) detalha o procedimento para divulgar problemas de segurança.

## <a name="author"></a>Autor

[Auth0](https://auth0.com)

## <a name="license"></a>Licença

Este projeto foi lançado sob a licença MIT. Confira o arquivo [LICENSE](LICENSE) para obter mais informações.
