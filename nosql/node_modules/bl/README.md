---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050286"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Status de build](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Um coletor, leitor e streamer de listas de Buffer do Node.js.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** é um objeto de armazenamento para coleções de Buffers do Node, expondo-os com a API legível do Buffer principal. Ele também funciona como um fluxo duplex para que você possa coletar buffers de um fluxo que os emita e emita buffers para um fluxo que os consuma.

Os buffers originais são mantidos intactos e as cópias são feitas somente conforme o necessário. Qualquer leitura que exija o uso de um só buffer original retornará apenas uma fatia desse buffer (com referência à mesma memória que o buffer original). As leituras que abrangem buffers executam a concatenação conforme o necessário e retornam os resultados de modo transparente.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Forneça um retorno de chamada no construtor e use-o como **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Observe que quando você usa o método *callback* dessa forma, o parâmetro resultante `data` é uma concatenação de todos os objetos `Buffer` na lista. Se você quiser evitar a sobrecarga dessa concatenação (em casos de necessidade de desempenho extremo), evite o método *callback* e apenas ouça `'end'`, como um fluxo padrão.

Ou para buscar uma URL usando [hyperquest ](https://github.com/substack/hyperquest) (deve funcionar com [request](http://github.com/mikeal/request) e até com http simples do Node.):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

Ou use-o como um fluxo legível para recompor uma lista de Buffers em uma fonte de saída:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
Nenhum argumento é _necessário_ para o construtor, mas você pode inicializar a lista passando um só objeto `Buffer` ou uma matriz de objetos `Buffer`.

`new` não é estritamente necessário. Se você não criar uma instância de um objeto, isso será feito automaticamente para que você possa criar uma instância simplesmente com:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Determina se o objeto passado é um `BufferList`. Será retornado `true` se o objeto passado for uma instância de `BufferList` **ou** de `BufferListStream`, caso contrário `false`.

N.B. não retornará `true` para instâncias de `BufferList` ou `BufferListStream` criadas por versões dessa biblioteca antes que esse método estático seja adicionado.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Obter o tamanho do arquivo, em bytes. Essa é a soma dos tamanhos de todos os buffers contidos na lista, menos o deslocamento inicial de um buffer semi-consumido no início. Deve representar com precisão o número total de bytes que podem ser lidos na lista.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` adiciona um buffer ou uma BufferList extra à lista interna. `this` é retornado para que possa ser encadeado.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` retornará o byte no índice especificado.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` retornará o byte no índice especificado.
O método `indexOf()` retorna o primeiro índice no qual um determinado elemento pode ser encontrado em BufferList ou -1 quando ele não está presente.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` retorna um novo objeto `Buffer` que contém os bytes dentro do intervalo especificado. `start` e `end` são opcionais e o padrão será o início e o fim da lista, respectivamente.

Se o intervalo solicitado abranger um só buffer interno, uma fatia desse buffer será retornada, compartilhando o intervalo de memória original desse Buffer. Se o intervalo abranger vários buffers, operações de cópia provavelmente ocorrerão para fornecer um Buffer uniforme.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` retorna um novo objeto `BufferList` que contém os bytes dentro do intervalo especificado. `start` e `end` são opcionais e o padrão será o início e o fim da lista, respectivamente.

Não será executada nenhuma cópia. Todos os buffers no resultado compartilham a memória com a lista original.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()`copia o conteúdo da lista no buffer `dest`, começando em `destStart` e contendo os bytes dentro do intervalo especificado com `srcStart` a `srcEnd`. `destStart`, `start` e `end` são opcionais e o padrão será o início do buffer `dest` e o início e o fim da lista, respectivamente.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` executa uma **shallow-copy** da lista. Os Buffers internos permanecem os mesmos, portanto, se você alterar os Buffers subjacentes, a alteração será refletida no original e na duplicata. Esse método é necessário quando você quer chamar `consume()` ou `pipe()` e ainda manter a lista original. Exemplo:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` deslocará bytes *do início da lista*. O número de bytes consumidos não precisa se alinhar com os tamanhos dos Buffers internos. Os deslocamentos iniciais serão calculado corretamente para fornecer uma exibição consistente dos dados.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` retornará uma representação de cadeia de caracteres do buffer. Os argumentos opcionais `start` e `end` são passados para `slice()`, enquanto o `encoding` é passado para `toString()` do Buffer resultante. Confira a documentação de [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) para obter mais informações.

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Todos os métodos de leitura de bytes padrão da interface `Buffer` são implementados e funcionarão entre os limites internos do Buffer de modo transparente.

Confira a documentação de <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> para saber como eles funcionam.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** é um **[Fluxo Duplex](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** de Node e, portanto, pode ser lido e gravado como um fluxo do Node padrão. Você também pode executar `pipe()` para/de uma instância de  **BufferListStream**.

O construtor recebe um retorno de chamada opcional, se fornecido. O retorno de chamada será chamado com um argumento de erro seguido por uma referência à instância **bl** , quando `bl.end()` for chamado (ou seja, de um fluxo canalizado). Esse é um método conveniente de coletar todo o conteúdo de um fluxo, principalmente quando o fluxo é *em partes*, como um fluxo de rede.

Geralmente, não é necessário nenhum argumento para o construtor, mas você pode inicializar a lista passando um só objeto `Buffer` ou uma matriz de objetos `Buffer`.

`new` não é estritamente necessário. Se você não criar uma instância de um objeto, isso será feito automaticamente para que você possa criar uma instância simplesmente com:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. Por motivos de compatibilidade com versões anteriores, `BufferListStream` é a exportação **padrão** quando você executa `require('bl')`:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Colaboradores

**bl** é oferecido pelos seguintes hackers:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Licença e direitos autorais

Direitos autorais (c) 2013-2019 colaboradores do bl (listados acima).

O bl está licenciado com a licença MIT. Todos os direitos não concedidos explicitamente na licença MIT são reservados. Confira o arquivo de LICENSE.md incluído para obter mais detalhes.
