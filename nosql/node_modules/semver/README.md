---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050050"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>semver(1) -- o controle de versão semântico do npm
===========================================

## <a name="install"></a>Instalar

```bash
npm install --save semver
````

## <a name="usage"></a>Uso

Como um módulo do Node:

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

Como um utilitário de linha de comando:

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>Versões

Uma "versão" é descrita pela `v2.0.0` especificação encontrada em <https://semver.org/>.

Um caractere `"="` ou `"v"` à esquerda é removido e ignorado.

## <a name="ranges"></a>Intervalos

Um `version range` é um conjunto de `comparators` que especifica versões que satisfazem o intervalo.

Um `comparator` é composto por um `operator` e uma `version`.  O conjunto de `operators` primitivos é:

* `<` inferior a
* `<=` igual ou inferior a
* `>` superior a
* `>=` igual ou superior a
* `=` igual.  Se não for especificado nenhum operador, a igualdade será assumida, portanto, esse operador é opcional, mas PODE ser incluído.

Por exemplo, o comparador `>=1.2.7` corresponderia às versões `1.2.7`, `1.2.8`, `2.5.3` e `1.3.9`, mas não às versões `1.2.6` ou `1.1.0`.

Os comparadores podem ser unidos por espaço em branco para formar um `comparator set`, que é atendido pela **interseção** de todos os comparadores que inclui.

Um intervalo é composto por um ou mais conjuntos de comparadores, unidos por `||`.  Uma versão corresponde a um intervalo somente quando cada comparador em pelo menos um dos conjuntos de comparadores separados por `||` é atendido pela versão.

Por exemplo, o intervalo `>=1.2.7 <1.3.0` corresponderia às versões `1.2.7`, `1.2.8` e `1.2.99`, mas não às versões `1.2.6`, `1.3.0` ou `1.1.0`.

O intervalo `1.2.7 || >=1.2.9 <2.0.0` corresponderia às versões `1.2.7`, `1.2.9` e `1.4.6`, mas não às versões `1.2.8` ou `2.0.0`.

### <a name="prerelease-tags"></a>Tags de pré-lançamento

Se uma versão tiver uma tag de pré-lançamento (por exemplo, `1.2.3-alpha.3`), ela só poderá atender aos conjuntos de comparadores se pelo menos um comparador com a mesma tupla `[major, minor, patch]` também tiver uma tag de pré-lançamento.

Por exemplo, o intervalo `>1.2.3-alpha.3` poderia corresponder à versão `1.2.3-alpha.7`, mas *não* seria atendido por `3.4.5-alpha.9`, embora `3.4.5-alpha.9` seja tecnicamente "superior a" `1.2.3-alpha.3` de acordo com as regras de classificação SemVer.  O intervalo de versão aceita apenas tags de pré-lançamento na versão `1.2.3`.  A versão `3.4.5` *satisfaria* o intervalo, pois não tem um sinalizador de pré-lançamento e `3.4.5` é supeior a `1.2.3-alpha.7`.

A finalidade desse comportamento é twofold.  Primeiro, as versões de pré-lançamento geralmente são atualizadas com bastante rapidez e contêm muitas alterações interruptivas (de acordo com o design do autor) que ainda não estão adequadas para consumo público.
Portanto, por padrão, elas são excluídas da semântica correspondente ao intervalo.

Em segundo lugar, um usuário que optou por usar uma versão de pré-lançamento indicou claramente a intenção de usar *esse conjunto específico* de versões alfa/beta/rc.  Ao incluir uma tag de pré-lançamento no intervalo, o usuário indica que está ciente do risco.  No entanto, ainda não é possível supor que ele tenha optado por assumir um risco semelhante no *próximo* conjunto de versões de pré-lançamento.

Observe que esse comportamento pode ser suprimido (tratando todas as versões de pré-lançamento como se fossem versões normais, para fins de correspondência de intervalo) definindo o sinalizador `includePrerelease` no objeto de opções para quaisquer [funções](https://github.com/npm/node-semver#functions) que façam correspondência de intervalo.

#### <a name="prerelease-identifiers"></a>Identificadores de pré-lançamento

O método `.inc` usa um argumento de cadeia de caracteres adicional `identifier` que acrescentará o valor da cadeia de caracteres como um identificador de pré-lançamento:

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

exemplo da linha de comando:

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Que depois pode ser usado para incrementação adicional:

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>Sintaxe de intervalo avançada

A sintaxe de intervalo avançada refina a escrita para comparadores primitivos de maneiras determinísticas.

Intervalos avançados podem ser combinados da mesma forma que comparadores primitivos usando espaço em branco ou `||`.

#### <a name="hyphen-ranges-xyz---abc"></a>Intervalos de hífen `X.Y.Z - A.B.C`

Especifica um conjunto inclusivo.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

Se uma versão parcial for fornecida como a primeira versão no intervalo inclusivo, as partes ausentes serão substituídas por zeros.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

Se uma versão parcial for fornecida como a segunda versão no intervalo inclusivo, todas as versões que começarem com as partes fornecidas da tupla serão aceitas, mas nada que seja maior do que as partes de tupla fornecidas.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>Intervalos de x `1.2.x` `1.X` `1.2.*` `*`

`X`, `x` ou `*` pode ser usado para "representar" um dos valores numéricos na tupla `[major, minor, patch]`.

* `*` := `>=0.0.0` (Qualquer versão satisfaz)
* `1.x` := `>=1.0.0 <2.0.0` (Correspondendo à versão principal)
* `1.2.x` := `>=1.2.0 <1.3.0` (Versões principais e secundárias mais recentes)

Um intervalo de versão parcial é tratado como um intervalo de x, portanto, o caractere especial é, de fato, opcional.

* `""` (cadeia de caracteres vazia) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>Intervalos de til `~1.2.3` `~1.2` `~1`

Permite alterações no nível do patch quando uma versão secundária é especificada no comparador.  Caso contrário, permite alterações de nível secundário.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (Igual a `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (Igual a `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (Igual a `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (Igual a `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Observe que os pré-lançamentos na versão `1.2.3` serão permitidos, se forem iguais ou superiores a `beta.2`.  Portanto, `1.2.3-beta.4` seria permitido, mas `1.2.4-beta.2` não seria, porque é um pré-lançamento de uma tupla `[major, minor, patch]`diferente.

#### <a name="caret-ranges-123-025-004"></a>Intervalos de circunflexo `^1.2.3` `^0.2.5` `^0.0.4`

Permite alterações que não modificam o dígito mais à esquerda diferente de zero na tupla `[major, minor, patch]`.  Em outras palavras, isso permite atualizações de patch e secundárias para versões `1.0.0` e superiores, atualizações de patch para versões `0.X >=0.1.0` e *nenhuma* atualização para versões `0.0.X`.

Muitos autores tratam uma versão `0.x` como se a `x` fosse o principal indicador de "alteração interruptiva".

Os intervalos de circunflexo são ideais quando o autor pode fazer alterações interruptivas entre as versões `0.2.4` e `0.3.0`, o que é uma prática comum.
No entanto, presume-se que *não* haverá alterações interruptivas entre `0.2.4` e `0.2.5`.  Isso permite alterações presumidas como aditivas (mas não interruptivas), de acordo com as práticas mais observadas.

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Observe que os pré-lançamentos na versão `1.2.3` serão permitidos, se forem iguais ou superiores a `beta.2`.  Portanto, `1.2.3-beta.4` seria permitido, mas `1.2.4-beta.2` não seria, porque é um pré-lançamento de uma tupla `[major, minor, patch]`diferente.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Observe que os pré-lançamentos na versão `0.0.3` *somente* serão permitidos, se forem iguais ou superiores a `beta`.  Portanto, `0.0.3-pr.2` seria permitido.

Ao analisar intervalos de circunflexos, um valor ausente `patch` é reescrito para o número `0`, mas permite flexibilidade dentro desse valor, mesmo que as versões principal e secundária sejam ambas `0`.

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

Valores ausentes de `minor` e `patch` serão reescritos para zero, mas também permitirão flexibilidade dentro desses valores, mesmo que a versão principal seja zero.

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>Gramática de intervalo

Juntando tudo isso, aqui está uma gramática Backus-Naur para intervalos, para ajudar autores de analisadores:

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>Funções

Todos os métodos e as classes assumem um argumento de objeto final `options`.  Todas as opções nesse objeto são `false` por padrão.  As opções com suporte são:

- `loose` Aceite melhor as cadeias de caracteres semver que não são tão válidas.
  (Toda saída resultante sempre terá 100% de conformidade com o modo estrito, é claro.)  Por motivos de compatibilidade com versões anteriores, se o argumento `options` for um valor booliano em vez de um objeto, ele será interpretado como um parâmetro `loose`.
- `includePrerelease` Defina para suprimir o [comportamento padrão](https://github.com/npm/node-semver#prerelease-tags) de excluir versões com tags de pré-lançamento dos intervalos, a menos que elas sejam aceitas explicitamente.

Comparadores e intervalos de modo estrito serão estritos sobre as cadeias de caracteres SemVer que analisam.

* `valid(v)`: retornar a versão analisada ou nulo se ela não for válida.
* `inc(v, release)`: retornar a versão incrementada pelo tipo de versão (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` ou `prerelease`) ou nulo se ela não for válida
  * `premajor` em uma chamada, aumentará a versão para a próxima versão principal e reduzirá para um pré-lançamento dessa versão principal.
    `preminor` e `prepatch` funcionam da mesma forma.
  * Se for chamado de uma versão não pré-lançamento, o `prerelease` funcionará da mesma forma que `prepatch`. Ele incrementa a versão de patch e depois faz um pré-lançamento. Se a versão de entrada já for um pré-lançamento, ele simplesmente a incrementará.
* `prerelease(v)`: retorna uma matriz de componentes de pré-lançamento ou nulo quando não existe nenhum. Exemplo: `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`: retornar o número de versão principal.
* `minor(v)`: retornar o número de versão secundária.
* `patch(v)`: retornar o número de versão de patch.
* `intersects(r1, r2, loose)`: retornar true quando os dois intervalos ou comparadores fornecidos interseccionam.
* `parse(v)`: tentar analisar uma cadeia de caracteres como uma versão semântica, retornando um objeto `SemVer` ou `null`.

### <a name="comparison"></a>Comparação

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`: `v1 == v2` É true quando eles são equivalentes logicamente, mesmo que não sejam exatamente a mesma cadeia de caracteres.  Você já sabe como comparar cadeias de caracteres.
* `neq(v1, v2)`: `v1 != v2` O oposto de `eq`.
* `cmp(v1, comparator, v2)`: passe uma cadeia de caracteres de comparação e ele chamará a função correspondente acima.  `"==="` e `"!=="` fazem uma comparação de cadeia de caracteres simples, mas são incluídos para garantir a integridade.  É gerado quando uma cadeia de caracteres de comparação inválida é fornecida.
* `compare(v1, v2)`: retornar `0` se `v1 == v2`, `1` se `v1` for maior ou `-1` se `v2` for maior.  Classifica em ordem crescente se passado para `Array.sort()`.
* `rcompare(v1, v2)`: o inverso da comparação.  Classifica uma matriz de versões em ordem decrescente quando passado para `Array.sort()`.
* `diff(v1, v2)`: retornar a diferença entre duas versões pelo tipo de versão (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` ou `prerelease`) ou nulo se as versões forem iguais.

### <a name="comparators"></a>Comparadores

* `intersects(comparator)`: retornar true se os comparadores interseccionarem

### <a name="ranges"></a>Intervalos

* `validRange(range)`: retornar o intervalo válido ou nulo se ele não for válido
* `satisfies(version, range)`: retornar true se a versão atender ao intervalo.
* `maxSatisfying(versions, range)`: retornar a versão mais alta da lista que atenda ao intervalo ou `null` se nenhuma delas atender.
* `minSatisfying(versions, range)`: retornar a versão mais baixa da lista que atenda ao intervalo ou `null` se nenhuma delas atender.
* `minVersion(range)`: retornar a versão mais baixa que possa corresponder ao intervalo determinado.
* `gtr(version, range)`: retornar `true` se a versão for superior a todas as versões possíveis no intervalo.
* `ltr(version, range)`: retornar `true` se a versão for inferior a todas as versões possíveis no intervalo.
* `outside(version, range, hilo)`: retornar true se a versão estiver fora dos limites do intervalo seja para cima ou para baixo.  O argumento `hilo` precisa ser a cadeia de caracteres `'>'` ou `'<'`.  (Essa é a função chamada por `gtr` e `ltr`.)
* `intersects(range)`: retornar true se um dos comparadores de intervalos interseccionar

Observe que, como os intervalos podem não ser contíguos, uma versão pode não ser superior a um intervalo, inferior a um intervalo *nem* atender a um intervalo.  Por exemplo, o intervalo `1.2 <1.2.9 || >2.0.0` teria um espaço de `1.2.9` até `2.0.0`, portanto, a versão `1.2.10` não seria superior ao intervalo (porque `2.0.1` atende, que é superior), nem inferior ao intervalo (já que `1.2.8` atende, que é inferior) e também não atenderia ao intervalo.

Se você quiser saber se uma versão atende ou não atende a um intervalo, use a função `satisfies(version, range)`.

### <a name="coercion"></a>Coerção

* `coerce(version)`: converte uma cadeia de caracteres em semver, se possível

Essa opção visa oferecer uma conversão bem indulgente de uma cadeia de caracteres que não é semver em semver. Ela procura o primeiro dígito em uma cadeia de caracteres e consome todos os caracteres restantes que atendem pelo menos a uma semver parcial (por exemplo, `1`, `1.2`, `1.2.3`) até o comprimento máximo permitido (256 caracteres).  Versões mais longas são simplesmente truncadas (`4.6.3.9.2-alpha2` se torna `4.6.3`).  Todo o texto ao redor é simplesmente ignorado (`v3.4 replaces v3.3.1` se torna `3.4.0`).  Somente o texto que não tem dígitos falha na conversão (`version one` não é válido).  O comprimento máximo de qualquer componente semver considerado para conversão é de 16 caracteres. Componentes mais longos serão ignorados (`10000000000000000.4.7.4` se tornará `4.7.4`).  O valor máximo de qualquer componente semver é `Number.MAX_SAFE_INTEGER || (2**53 - 1)`. Componentes de valor mais alto são inválidos (`9999999999999999.4.7.4` provavelmente é inválido).
