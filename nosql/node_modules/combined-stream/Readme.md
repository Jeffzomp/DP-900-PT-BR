---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050285"
---
# <a name="combined-stream"></a>combined-stream

Um fluxo que emite vários outros fluxos, um após o outro.

**NB** No momento, `combined-stream` funciona apenas com fluxos da versão 1. Há ações contínuas para mudar essa biblioteca para os fluxos da versão 2. Qualquer ajuda é bem-vinda. :) Enquanto isso, você pode explorar outras bibliotecas que dão suporte ao streams2, oferecendo compatibilidade maior ou menor com o `combined-stream`.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2): Uma substituição imediata do módulo combined-stream compatível com o streams2.

- [multistream](https://www.npmjs.com/package/multistream): Um fluxo que emite vários outros fluxos, um após o outro.

## <a name="installation"></a>Instalação

``` bash
npm install combined-stream
```

## <a name="usage"></a>Uso

Veja um exemplo simples que mostra como você pode usar combined-stream para combinar dois arquivos em um:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Embora o exemplo acima funcione muito bem, ele pausará todos os fluxos de origem até que eles sejam necessários. Se você não quiser que isso aconteça, defina `pauseStreams` como `false`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Mas e se você ainda não tiver todos os fluxos de origem ou não quiser alocar os recursos (descritores de arquivo, memória etc.) para eles imediatamente?
Nesse caso, basta fornecer um retorno de chamada que forneça o fluxo chamando uma função `next()`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Retorna um novo objeto de fluxo combinado. As opções disponíveis são:

* `maxDataSize`
* `pauseStreams`

O efeito dessas opções está descrito abaixo.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Se você deve aplicar pressão de retorno aos fluxos subjacentes. Se definido como `false`, os fluxos subjacentes nunca serão pausados. Se definido como `true`, os fluxos subjacentes serão pausados logo depois de serem acrescentados e também quando `delayedStream.pipe()` quiser uma limitação.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

A quantidade máxima de bytes (ou caracteres) a serem armazenados em buffer para todos os fluxos de origem.
Se esse valor for excedido, `combinedStream` emitirá um evento `'error'`.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

A quantidade de bytes (ou caracteres) armazenados em buffer por `combinedStream` no momento.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Acrescenta o `stream` fornecido ao objeto combinedStream. Se `pauseStreams` for definido como `true, esse fluxo também será pausado imediatamente.

`streams` também pode ser uma função que usa um parâmetro chamado `next`. `next` é uma função que precisa ser invocada para fornecer o fluxo `next`. Confira o exemplo acima.

Independentemente de como o `stream` é acrescentado, combined-stream sempre anexa um ouvinte `'error'` a ele, para que você não precise fazer isso manualmente.

Caso especial: `stream` também pode ser uma cadeia de caracteres ou um buffer.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

Você não deve chamar isso, `combinedStream` cuida sozinho da canalização dos fluxos acrescentados para si mesmo.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Faz com que `combinedStream` comece a esvaziar os fluxos que gerencia. A função é idempotente e também sempre emite um evento `'resume'`, que geralmente vai para o fluxo que está sendo esvaziado no momento.

### <a name="combinedstreampause"></a>combinedStream.pause();

Se `combinedStream.pauseStreams` está definido como `false`, essa opção não faz nada.
Caso contrário, um evento `'pause'` é emitido e vai para o fluxo que está sendo esvaziado no momento, para que você possa usá-lo para aplicar a pressão de retorno.

### <a name="combinedstreamend"></a>combinedStream.end();

Define `combinedStream.writable` como false, emite um evento `'end'` e remove todos os fluxos da fila.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

O mesmo que `combinedStream.end()`, exceto que ele emite um evento `'close'` em vez de `'end'`.

## <a name="license"></a>Licença

O combined-stream está licenciado com a licença MIT.
