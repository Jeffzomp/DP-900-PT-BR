---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050336"
---
# <a name="stoppable"></a>Stoppable

[![Status de build](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> O `server.close()` do Node é a maneira [de funcionamento dele que se espera por padrão](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Resumo

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable para de aceitar novas conexões e fecha as conexões existentes e ociosas (incluindo keep-alives) sem encerrar solicitações que estão em atividade.

## <a name="requirements"></a>Requisitos

- Node.js v6 ou superior

Há suporte *não oficial* ao Node.js v4.x.

## <a name="installation"></a>Instalação

```bash
yarn add stoppable
```

(ou use o npm)

## <a name="usage"></a>Uso

**constructor**

```js
stoppable(server, grace)
```

Decora a instância de servidor com um método `stop`.
Retorna a instância de servidor, portanto, pode ser encadeada ou executada como uma instrução autônoma.

- server: Qualquer instância de servidor HTTP ou HTTPS
- grace: Milissegundos a aguardar antes de forçar o fechamento das conexões

`grace` tem como padrão Infinity (não forçar o fechamento).
Se você quiser encerrar imediatamente todos os soquetes, use a carência 0.

**stop()**

```js
server.stop(callback)
```

Fecha o servidor.

- callback: passado para a função existente `server.close` para registrar automaticamente um evento 'close'.
O primeiro argumento é um erro e o segundo argumento é um booliano que indica se a parada foi normal.

## <a name="design-decisions"></a>Decisões de design

- A aplicação de patch de macaco geralmente é ruim, mas neste caso é a API mais adequada. Vamos chamá-la de "decoração".
- `grace` pode ser especificado em `stop`, mas é melhor corresponder à API existente `server.close`.
- Os clientes devem ser tratados com respeito, portanto, não estamos apenas destruindo soquetes, estamos enviando pacotes `FIN` primeiro.
- Qualquer solução para esse problema requer o registro em cada conexão e solicitação/resposta.
Estamos fazendo um trabalho mínimo nesses caminhos de código "quentes" e atrasando-o ao máximo possível para o método `stop` real.

## <a name="performance"></a>Desempenho

Não há como fornecer essa funcionalidade sem o registro na conexão, na desconexão, na solicitação e na resposta.
No entanto, Stoppable se esforça para fazer um trabalho mínimo em caminhos de código quente e usar estruturas de dados ideais.

Eu gostaria de ver os parâmetros de comparação de desempenho do mundo real. O parâmetro de comparação de artilharia de loopback simples incluído na biblioteca mostra muito pouca sobrecarga do uso de um stoppable server:

### <a name="without-stoppable"></a>Sem Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Com Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Licença

MIT