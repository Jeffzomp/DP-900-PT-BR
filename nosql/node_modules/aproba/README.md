---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050374"
---
<a name="aproba"></a>aproba
======

Um validador de argumento de função extremamente leve

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

Os tipos válidos são:

| tipo | descrição
| :--: | :----------
| *    | corresponde a qualquer tipo
| Um    | `Array.isArray` ou um objeto `arguments`
| S    | typeof == cadeia de caracteres
| N    | typeof == número
| F    | typeof == função
| O    | typeof == objeto e não tipo A e não tipo E
| B    | typeof == booliano
| E    | `instanceof Error` ou `null` **(especial: veja abaixo)**
| Z    | == `null`

As falhas de validação geram um dos três tipos de exceção, diferenciados por uma propriedade `code` igual a `EMISSINGARG`, `EINVALIDTYPE` ou `ETOOMANYARGS`.

Se você passar um tipo inválido, ele será gerado com um código `EUNKNOWNTYPE`.

Se um argumento **error** for encontrado e não for nulo, os argumentos restantes serão opcionais.  Ou seja, se você diz `ESO`, isso é como usar um `E` sem mágica em: `E|ESO|ZSO`.

### <a name="but-i-have-optional-arguments"></a>Mas há argumentos opcionais?

Você pode fornecer mais de uma assinatura separando-as com barras verticais `|`.
Se alguma assinatura corresponder aos argumentos, elas serão consideradas válidas.

Então, por exemplo, se você quiser escrever uma assinatura para `fs.createWriteStream`.  A documentação a descreverá assim:

```
fs.createWriteStream(path[, options])
```

Essa seria uma assinatura de `SO|S`.  Ou seja, uma cadeia de caracteres e um objeto ou apenas uma cadeia de caracteres.

Agora, se você ler a documentação completa do `fs`, verá que o caminho também pode ser um buffer.  E as opções podem ser uma cadeia de caracteres, ou seja:
```
path <String> | <Buffer>
options <String> | <Object>
```

Para reproduzir isso, você precisa enumerar totalmente todas as combinações possíveis e isso implica uma assinatura de `SO|SS|OO|OS|S|O`.  A dificuldade é um recurso: Ele demonstra a complexidade adicionada à API quando esse tipo de coisa é feito.


### <a name="browser-support"></a>Suporte ao navegador

Essa opção não tem dependências e deve funcionar em navegadores, embora os rastreamentos de pilha sejam mais complexos.

### <a name="why-this-exists"></a>Por que isso existe

Eu queria um validador de argumento muito simples. Ele precisava fazer duas coisas:

1. Ser mais conciso e mais fácil de usar do que as declarações

2. Não incentivar um bikeshed infinito de DSLs

É por isso que os tipos são especificados por um só caractere e não existem argumentos opcionais. 

A intenção não é validar dados do usuário. Trata-se especificamente de declarar a interface das funções.

Se você precisar de uma validação maior, eu encorajo você a escrevê-las manualmente ou procurar outra opção.

